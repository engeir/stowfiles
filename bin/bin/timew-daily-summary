#!/usr/bin/env python3
"""
Show Timewarrior time grouped by date and tag.
Usage: timew-daily-summary [timewarrior filter]
Examples:
    timew-daily-summary :week
    timew-daily-summary :month
    timew-daily-summary 2026-01-19 - 2026-01-23
"""

import json
import subprocess
import sys
from datetime import datetime
from collections import defaultdict


def parse_duration(seconds):
    """Convert seconds to HH:MM:SS format"""
    hours = seconds // 3600
    minutes = (seconds % 3600) // 60
    secs = seconds % 60
    return f"{hours:d}:{minutes:02d}:{secs:02d}"


def main():
    # Get filter from command line arguments, default to :week
    filter_args = sys.argv[1:] if len(sys.argv) > 1 else [":week"]

    # Run `timew` export with the filter
    try:
        result = subprocess.run(
            ["timew", "export"] + filter_args,
            capture_output=True,
            text=True,
            check=True,
        )
    except subprocess.CalledProcessError as e:
        print(f"Error running timew export: {e}", file=sys.stderr)
        sys.exit(1)

    # Parse JSON output
    try:
        entries = json.loads(result.stdout)
    except json.JSONDecodeError as e:
        print(f"Error parsing JSON: {e}", file=sys.stderr)
        sys.exit(1)

    # Group by date and tag
    # Structure: {date: {tag: total_seconds}}
    daily_tags = defaultdict(lambda: defaultdict(int))

    for entry in entries:
        # Get start time
        start = datetime.fromisoformat(entry["start"].replace("Z", "+00:00"))
        date = start.date()

        # Get duration
        if "end" in entry:
            end = datetime.fromisoformat(entry["end"].replace("Z", "+00:00"))
            duration = (end - start).total_seconds()
        else:
            # Ongoing task
            end = datetime.now(start.tzinfo)
            duration = (end - start).total_seconds()

        # Get tags
        tags = entry.get("tags", ["(untagged)"])

        # Add duration to each tag for this date
        for tag in tags:
            daily_tags[date][tag] += duration

    # Sort dates
    sorted_dates = sorted(daily_tags.keys())

    # Print results
    if not sorted_dates:
        print("No time entries found for the specified period.")
        return

    for date in sorted_dates:
        day_name = date.strftime("%a")
        date_str = date.strftime("%Y-%m-%d")
        print(f"\n{date_str} ({day_name})")
        print("-" * 50)

        # Sort tags alphabetically
        sorted_tags = sorted(daily_tags[date].items())
        day_total = 0

        for tag, seconds in sorted_tags:
            time_str = parse_duration(int(seconds))
            print(f"  {tag:30s} {time_str}")
            day_total += seconds

        print(f"  {'Total:':30s} {parse_duration(int(day_total))}")

    # Print grand total
    grand_total = sum(sum(tags.values()) for tags in daily_tags.values())
    print(f"\n{'Grand Total:':50s} {parse_duration(int(grand_total))}")


if __name__ == "__main__":
    main()
