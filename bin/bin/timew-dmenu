#!/usr/bin/env bash

if ! command -v timew >/dev/null; then
    notify-send "Error" "timew command not found. See https://timewarrior.net/ for installation instructions."
    exit 1
fi

if ! command -v dmenu >/dev/null; then
    notify-send "Error" "dmenu command not found."
    exit 1
fi

tags=(
    "LEARN"
    "ANSIBLE"
    "PUPPET"
    "SATELLITE"
    "TIME-WASTE"
    "new"
)

get-running-tags() {
    if timew >/dev/null 2>&1; then
        timew | grep -i "tracking" | sed 's/Tracking //'
    else
        echo ""
    fi
}

get-all-tags() {
    timew tags | tail -n +4 | awk '{print $1}'
}

start-func() {
    # Get all available tags
    all_tags=$(cat <(get-all-tags) <(printf "%s\n" "${tags[@]}") | tr " " "\n" | sed '/^$/d' | sort | uniq)

    # Use dmenu for tag selection (allow multiple selections with newlines)
    selected_tags=$(echo "$all_tags" | dmenu -c -l 10 -p "Select tags to start (Ctrl+Enter for multiple):")

    if [[ -z $selected_tags ]]; then
        exit 0
    fi

    # Handle "new" tag
    if echo "$selected_tags" | grep -q "new"; then
        new_tag=$(echo "" | dmenu -c -p "Enter new tag name:")
        if [[ -z $new_tag ]]; then
            notify-send "Error" "Cannot have empty tags"
            exit 1
        fi
        selected_tags=$(echo "$selected_tags" | sed "s/new/${new_tag^^}/")
    fi

    # Convert to array properly: split by newlines AND spaces, then remove duplicates
    tags_array=()
    while IFS= read -r line; do
        # Split each line by spaces and add to array
        for tag in "${line[@]}"; do
            # Only add if not already in array
            found=false
            for existing in "${tags_array[@]}"; do
                if [[ $existing == "$tag" ]]; then
                    found=true
                    break
                fi
            done
            if [[ $found == false ]]; then
                tags_array+=("$tag")
            fi
        done
    done <<<"$selected_tags"

    if [[ ${#tags_array[@]} -eq 0 ]]; then
        exit 0
    fi

    # Get last session info before starting new one
    last_session_line=$(timew summary @1 2>/dev/null | grep -E '^W[0-9]+')
    if [[ -n $last_session_line ]]; then
        last_duration=$(echo "$last_session_line" | awk '{print $(NF-1)}')
        last_tags=$(echo "$last_session_line" | awk '{for(i=5;i<NF-3;i++) printf "%s ", $i; print ""}' | xargs)
    fi

    result=$(timew start "${tags_array[@]}" 2>&1)

    if [[ $? -eq 0 ]]; then
        if [[ -n $last_duration ]]; then
            if [[ -n $last_tags ]]; then
                notify-send "TimeWarrior" "Started tracking: ${tags_array[*]}\nLast session: $last_tags ($last_duration)"
            else
                notify-send "TimeWarrior" "Started tracking: ${tags_array[*]}\nLast session: $last_duration"
            fi
        else
            notify-send "TimeWarrior" "Started tracking: ${tags_array[*]}"
        fi
    else
        notify-send "Error" "Failed to start tracking: $result"
    fi
}

stop-func() {
    current_tags=$(get-running-tags)

    if [[ -z $current_tags ]]; then
        notify-send "TimeWarrior" "No currently running time tracking"
        exit 0
    fi

    # Show current tags + "all" option
    stop_options=$(echo -e "${current_tags}\nall")
    selected=$(echo "$stop_options" | dmenu -c -l 10 -p "Select tags to stop:")

    if [[ -z $selected ]]; then
        exit 0
    fi

    if [[ $selected == "all" ]]; then
        result=$(timew stop 2>&1)
    else
        result=$(timew stop "$selected" 2>&1)
    fi

    if [[ $? -eq 0 ]]; then
        notify-send "TimeWarrior" "Stopped tracking: $selected"
    else
        notify-send "Error" "Failed to stop tracking: $result"
    fi
}

# === Main program

current_tags=$(get-running-tags)

if [[ -z $current_tags ]]; then
    status_msg="No tags currently being tracked"
else
    status_msg="Currently tracking: $current_tags"
fi

# Show current status and ask for action
action=$(echo -e "start\nstop" | dmenu -c -l 2 -p "$status_msg - Choose action:")

case "$action" in
    start)
        start-func
        ;;
    stop)
        stop-func
        ;;
    *)
        exit 0
        ;;
esac
